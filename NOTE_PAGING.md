# 페이징 한계 돌파

[페이징 + 컬렉션을 다루는 방법]

1. *ToOne 관계는 모두 fetch join (페이징에 영향 X)
2. *ToMany 관계는 (컬렉션)은 지연 로딩으로 조회한다.
    1. 지연로딩 최적화를 위해 `hibernate.default_batch_fetch_size`, `@BatchSize` 를 적용한다.
        1. 컬렉션이나 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.
        2. 사이즈는 100~1000 사이를 권장 (DB 에 따라 SQL IN 절 파라미터 max=1000).
       ```
       1000으로 잡으면 한번에 DB -> 애플리케이션으로 데이터를 불러오므로, DB 에 순간 부하가 증가할 수 있다. 
       
       하지만 애플리케이션은 100 이든 1000 이든 결국 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다. 
       (한 번에 1000 을 가져온다고 out of memory 가 날 확률이 높은가? NO)
       
       결국, DB든 애플리케이션이든 순간 부하를 견딜 수 있는 정도로 결정하여야 함. 
       ```

[장점]

1. 쿼리 호출 수가 1+N -> 1+1 으로 최적화
2. join 보다 DB 데이터 전송량이 최적화 된다.
3. fetch join 과 비교하여 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다.
4. **컬렉션 페치 조인은 페이징이 불가하지만, 이 방법은 페이징이 가능하다.** 
