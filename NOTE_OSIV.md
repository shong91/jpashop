# OSIV 와 성능 최적화

- Open Session In View; Hibernate
- Open Entity In View; JPA
- spring.jpa.open-in.view: default = true

**OSIV ON**

OSIV 전략은 최초 DB 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 DB 커넥션을 유지한다.

=> View Template 이나 API 컨트롤러에셔 지연 로딩이 가능했던 이유.

BUT 이 전략은 너무 오랜 시간동안 DB 커넥션 리소스를 사용하기 때문에,

실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다.

=> 장애로 이어질 가능성

ex) 외부 API 와 연동 시, 외부 API 대기 시간만큼 커넥션 리소스를 반환하지 못하고 유지하고 있게 됨

**OSIV OFF**

트랜잭션 종료 시 영속성 컨텍스트를 닫고, DB 커넥션도 반환한다.

=> 커넥션 리소스 낭비 X

BUT 이 경우 모든 지연로딩을 트랜잭션 안에서 처리하여야 함.

=> 트랜잭션이 끝나기 전에 지연로딩을 강제로 호출해주거나, fetch join 으로 처리

모든 지연로딩 로직까지 관리하기엔 하나의 서비스에서 관리하는 것이 너무 많아지지 않고, 코드가 더러워지는 문제.

**해결책**

1. Command 와 Query 를 분리

"비즈니스 로직과 조회용 쿼리" - 둘의 관심사를 명확하게 분리하는 것이 유지보수 관점에서 유의미함.

비즈니스 로직은 특정 엔티티를 CUD 하는 것이므로 큰 성능 문제가 없으나,

복잡한 화면을 출력하는 조회 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하다.

- *Service: 핵심 비즈니스 로직
- *QueryService: 화면/API 에 맞춘 서비스 (주로 읽기 전용 트랜잭션 사용)

**어떻게 하는게 적합할까? (예)**

- 실시간 API 는 OSIV OFF,

- ADMIN 같이 커넥션을 많이 사용하지 않는 곳에서는 OSIV ON
